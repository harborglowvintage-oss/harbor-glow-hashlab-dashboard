<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Mining Analytics</title>
    <link rel="icon" type="image/png" href="/static/img/bolt.png">
    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Chart.js Plugins -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            background-color: #000;
            color: #fff;
            font-family: 'Space Mono', 'Fira Code', 'Courier New', monospace;
            height: 100%;
        }

        body {
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(6, 182, 212, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(16, 185, 129, 0.05) 0%, transparent 50%);
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
        }

        .header {
            margin-bottom: 32px;
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .title {
            font-size: 32px;
            font-weight: bold;
            background: linear-gradient(135deg, #06b6d4, #10b981);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
            font-weight: 400;
        }

        .breadcrumb {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 24px;
            font-size: 12px;
            color: #666;
            font-family: 'Space Mono', monospace;
        }

        .breadcrumb a {
            color: #06b6d4;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .breadcrumb a:hover {
            color: #10b981;
            text-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }

        .breadcrumb span {
            color: #444;
        }

        .miner-selector {
            display: flex;
            gap: 12px;
            margin: 24px 0;
            flex-wrap: wrap;
        }

        .miner-btn {
            padding: 10px 16px;
            border: 1px solid #333;
            background-color: #111;
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Space Mono', monospace;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .miner-btn:hover {
            border-color: #06b6d4;
            box-shadow: 0 0 12px rgba(6, 182, 212, 0.2);
            transform: translateY(-2px);
        }

        .miner-btn.active {
            background-color: #06b6d4;
            color: #000;
            border-color: #06b6d4;
            box-shadow: 0 0 16px rgba(6, 182, 212, 0.4);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }

        .stat-card {
            background-color: rgba(17, 24, 39, 0.6);
            border: 1px solid #1f2937;
            border-radius: 8px;
            padding: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .stat-card:hover {
            border-color: #06b6d4;
            background-color: rgba(17, 24, 39, 0.9);
            box-shadow: 0 0 16px rgba(6, 182, 212, 0.1);
            transform: translateY(-4px);
        }

        .stat-icon {
            font-size: 28px;
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.7px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: #06b6d4;
            margin-bottom: 4px;
            letter-spacing: -0.5px;
        }

        .stat-trend {
            font-size: 12px;
            color: #10b981;
            font-weight: 500;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(550px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .chart-container {
            background-color: rgba(17, 24, 39, 0.6);
            border: 1px solid #1f2937;
            border-radius: 12px;
            padding: 28px;
            min-height: 420px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .chart-container:hover {
            border-color: #06b6d4;
            background-color: rgba(17, 24, 39, 0.95);
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.15);
        }

        .chart-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #06b6d4;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        .chart-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 350px;
            position: relative;
        }

        /* Chart.js specific styling */
        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #1f2937;
            font-size: 13px;
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-label {
            color: #888;
            font-weight: 500;
        }

        .metric-value {
            color: #06b6d4;
            font-weight: 700;
            font-family: 'Courier New', monospace;
        }

        .info-box {
            background-color: rgba(17, 24, 39, 0.6);
            border: 1px solid #1f2937;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 16px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .info-box:hover {
            border-color: #06b6d4;
            background-color: rgba(17, 24, 39, 0.9);
        }

        .info-title {
            font-size: 14px;
            font-weight: 700;
            color: #06b6d4;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-text {
            font-size: 13px;
            color: #aaa;
            line-height: 1.6;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 200px;
            color: #06b6d4;
            font-size: 13px;
        }

        .spinner {
            border: 2px solid #1f2937;
            border-top: 2px solid #06b6d4;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background-color: rgba(239, 68, 68, 0.1);
            border: 1px solid #ef4444;
            color: #f87171;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 16px;
        }

        .recommendation-item {
            padding: 10px 0;
            border-bottom: 1px solid #1f2937;
            font-size: 13px;
            color: #aaa;
            line-height: 1.5;
        }

        .recommendation-item:last-child {
            border-bottom: none;
        }

        svg {
            max-width: 100%;
            height: auto;
        }

        .chart-bar {
            fill: url(#barGradient);
            transition: opacity 0.2s ease;
        }

        .chart-bar:hover {
            opacity: 0.8;
        }

        .chart-label {
            font-size: 11px;
            fill: #888;
            font-family: 'Space Mono', monospace;
        }

        .chart-value {
            font-size: 12px;
            fill: #06b6d4;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .chart-grid {
            stroke: #1f2937;
            stroke-width: 1;
            opacity: 0.3;
        }

        .gauge-circle {
            fill: none;
            stroke: #1f2937;
            stroke-width: 3;
        }

        .gauge-progress {
            fill: none;
            stroke: url(#gaugeGradient);
            stroke-width: 3;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .gauge-text {
            font-size: 16px;
            font-weight: 700;
            text-anchor: middle;
            fill: #06b6d4;
            font-family: 'Space Mono', monospace;
        }

        .gauge-label {
            font-size: 11px;
            text-anchor: middle;
            fill: #888;
            font-family: 'Space Mono', monospace;
        }

        .line-chart-path {
            fill: none;
            stroke: url(#lineGradient);
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .line-chart-area {
            fill: url(#areaGradient);
            opacity: 0.1;
        }

        .chart-dot {
            fill: #06b6d4;
            r: 3;
        }

        .chart-dot:hover {
            r: 5;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 24px;
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="title">‚ö° Advanced Mining Analytics</div>
            <div class="subtitle">Real-time fleet performance monitoring and insights</div>
        </div>

        <!-- Miner Selector -->
        <div class="miner-selector" id="minerSelector"></div>

        <!-- Stats Grid -->
        <div class="stats-grid" id="statsGrid"></div>

        <!-- Charts Section -->
        <div class="charts-grid">
            <div class="chart-container">
                <div class="chart-title">‚ö° Hashrate Distribution (Local vs Pool)</div>
                <div class="chart-content">
                    <div class="chart-wrapper">
                        <canvas id="hashrateChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <div class="chart-title">üìä Power Efficiency Trend</div>
                <div class="chart-content">
                    <div class="chart-wrapper">
                        <canvas id="efficiencyChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pool Comparison Chart (Oversized & Functional) -->
        <div class="chart-container" style="margin-top: 32px; min-height: 550px; background: linear-gradient(135deg, rgba(6,182,212,0.05), rgba(16,185,129,0.05)); border: 2px solid #06b6d4; border-radius: 12px; padding: 24px;">
            <div class="chart-title" style="font-size: 18px; margin-bottom: 20px; letter-spacing: 1px;">‚ö° POOL VS LOCAL HASHRATE COMPARISON</div>
            
            <!-- Comparison Stats -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px;">
                <div style="background: #0a1416; border: 1px solid #06b6d4; border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="color: #06b6d4; font-size: 12px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">Local Total Hashrate</div>
                    <div id="localHashrateTotal" style="color: #10b981; font-size: 24px; font-weight: bold;">0.00 TH/s</div>
                </div>
                <div style="background: #0a1416; border: 1px solid #f59e0b; border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="color: #f59e0b; font-size: 12px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">Pool Total Hashrate</div>
                    <div id="poolHashrateTotal" style="color: #f59e0b; font-size: 24px; font-weight: bold;">0.00 TH/s</div>
                </div>
                <div style="background: #0a1416; border: 1px solid #8b5cf6; border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="color: #8b5cf6; font-size: 12px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">Difference</div>
                    <div id="hashrateDifference" style="color: #8b5cf6; font-size: 24px; font-weight: bold;">0.00 TH/s</div>
                </div>
                <div style="background: #0a1416; border: 1px solid #ec4899; border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="color: #ec4899; font-size: 12px; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px;">Variance</div>
                    <div id="hashrateVariance" style="color: #ec4899; font-size: 24px; font-weight: bold;">0%</div>
                </div>
            </div>

            <!-- Large Bar Chart -->
            <div style="background: #050a0c; border: 1px solid #1a3a3f; border-radius: 8px; padding: 24px; margin-bottom: 24px;">
                <svg id="poolComparisonChart" viewBox="0 0 1000 400" style="width: 100%; height: 400px; display: block;">
                    <defs>
                        <linearGradient id="localGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#06b6d4;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:0.3" />
                        </linearGradient>
                        <linearGradient id="poolGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#f59e0b;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#f59e0b;stop-opacity:0.3" />
                        </linearGradient>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    <!-- Grid and axes will be drawn by JavaScript -->
                    <g id="chartContent"></g>
                </svg>
            </div>

            <!-- Legend & Status -->
            <div style="display: flex; gap: 24px; padding: 16px; background: #0a1416; border-radius: 8px; border: 1px solid #1a3a3f;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 16px; height: 16px; background: #06b6d4; border-radius: 2px;"></div>
                    <span style="color: #06b6d4; font-size: 12px;">Local Miners</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 16px; height: 16px; background: #f59e0b; border-radius: 2px;"></div>
                    <span style="color: #f59e0b; font-size: 12px;">Luxor Pool</span>
                </div>
                <div style="flex: 1;"></div>
                <div id="poolStatus" style="color: #888; font-size: 12px;">
                    Loading pool data...
                </div>
            </div>
        </div>

        <!-- Detailed Info -->
        <div class="info-box">
            <div class="info-title">System Overview</div>
            <div id="systemOverview" class="loading">
                <div class="spinner"></div>
                Loading system overview...
            </div>
        </div>

        <!-- Miner Performance Analysis -->
        <div class="info-box">
            <div class="info-title">üî¨ AI Miner Performance Analysis (24h)</div>
            <div id="minerAnalysis" class="loading">
                <div class="spinner"></div>
                Analyzing miner performance...
            </div>
        </div>

        <!-- Recommendations -->
        <div class="info-box">
            <div class="info-title">‚ö° Fleet Recommendations</div>
            <div id="recommendations" class="loading">
                <div class="spinner"></div>
                Generating recommendations...
            </div>
        </div>
    </div>

    <script>
        const app = {
            miners: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H-nerd'],
            selectedMiner: 'A',
            data: null,
            poolData: {},
            refreshInterval: 10000,
            charts: {
                hashrate: null,
                efficiency: null
            },

            init() {
                this.renderMinerSelector();
                this.loadData();
                setInterval(() => this.loadData(), this.refreshInterval);
            },

            renderMinerSelector() {
                const selector = document.getElementById('minerSelector');
                selector.innerHTML = this.miners.map(miner => `
                    <button class="miner-btn ${miner === this.selectedMiner ? 'active' : ''}" 
                            onclick="app.selectMiner('${miner}')" 
                            data-miner="${miner}">
                        Miner ${miner}
                    </button>
                `).join('');
            },

            selectMiner(name) {
                this.selectedMiner = name;
                this.renderMinerSelector();
                this.updateUI();
            },

            async loadData() {
                try {
                    const response = await fetch('/api/pool-comparison');
                    if (!response.ok) {
                        if (response.status === 302 || response.status === 401) {
                            window.location.href = '/login';
                            return;
                        }
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const json = await response.json();
                    this.data = json.local;
                    this.poolData = json.pool || {};
                    this.updateUI();
                } catch (error) {
                    console.error('Failed to load data:', error);
                    const errorHtml = `<div class="error">‚ö†Ô∏è Error loading data: ${error.message}</div>`;
                    document.getElementById('statsGrid').innerHTML = errorHtml;
                }
            },

            updateUI() {
                this.renderStats();
                this.renderCharts();
                this.renderPoolComparisonChart();
                this.renderSystemOverview();
                this.renderMinerAnalysis();
                this.renderRecommendations();
            },

            renderCharts() {
                this.renderHashrateChart();
                this.renderEfficiencyChart();
            },

            renderHashrateChart() {
                if (!this.data) return;

                const ctx = document.getElementById('hashrateChart');
                if (!ctx) return;

                const miners = this.miners;
                const localHashrates = miners.map(m => {
                    const minerData = Object.values(this.data).find(d => d.name === m);
                    return minerData?.hashrate_1m || 0;
                });

                const poolHashrates = miners.map(m => {
                    return (this.poolData[m]?.hashrate) || 0;
                });

                // Destroy previous chart if exists
                if (this.charts.hashrate) {
                    this.charts.hashrate.destroy();
                }

                this.charts.hashrate = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: miners.map(m => `Miner ${m}`),
                        datasets: [
                            {
                                label: 'Local Miners',
                                data: localHashrates,
                                backgroundColor: 'rgba(6, 182, 212, 0.8)',
                                borderColor: '#06b6d4',
                                borderWidth: 2,
                                borderRadius: 6,
                                borderSkipped: false,
                                barPercentage: 0.7,
                                categoryPercentage: 0.85,
                            },
                            {
                                label: 'Luxor Pool',
                                data: poolHashrates,
                                backgroundColor: 'rgba(245, 158, 11, 0.8)',
                                borderColor: '#f59e0b',
                                borderWidth: 2,
                                borderRadius: 6,
                                borderSkipped: false,
                                barPercentage: 0.7,
                                categoryPercentage: 0.85,
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#888',
                                    font: { family: "'Space Mono', monospace", size: 13, weight: '600' },
                                    padding: 16,
                                    boxWidth: 14,
                                    boxHeight: 14,
                                    borderRadius: 3,
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(17, 24, 39, 0.95)',
                                borderColor: '#06b6d4',
                                borderWidth: 1,
                                titleColor: '#06b6d4',
                                bodyColor: '#aaa',
                                cornerRadius: 6,
                                padding: 12,
                                displayColors: true,
                                callbacks: {
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' TH/s';
                                    }
                                }
                            },
                            datalabels: {
                                anchor: 'end',
                                align: 'start',
                                offset: 8,
                                color: function(context) {
                                    return context.dataset.borderColor;
                                },
                                font: {
                                    family: "'Courier New', monospace",
                                    size: 11,
                                    weight: 'bold'
                                },
                                formatter: function(value) {
                                    return value > 0 ? value.toFixed(2) + ' TH' : '';
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: false,
                                grid: {
                                    display: false,
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#888',
                                    font: { family: "'Space Mono', monospace", size: 12, weight: '600' },
                                    maxRotation: 45,
                                    minRotation: 30,
                                    padding: 8
                                }
                            },
                            y: {
                                beginAtZero: true,
                                stacked: false,
                                title: {
                                    display: true,
                                    text: 'Hashrate (TH/s)',
                                    color: '#06b6d4',
                                    font: { family: "'Space Mono', monospace", size: 13, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(31, 41, 55, 0.3)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#888',
                                    font: { family: "'Courier New', monospace", size: 11, weight: 'bold' },
                                    padding: 8,
                                    callback: function(value) {
                                        return value.toFixed(1);
                                    }
                                }
                            }
                        }
                    },
                    plugins: [ChartDataLabels]
                });
            },

            renderEfficiencyChart() {
                if (!this.data) return;

                const ctx = document.getElementById('efficiencyChart');
                if (!ctx) return;

                const miners = Object.values(this.data).slice(0, 8);
                const labels = miners.map((_, i) => `T${i}`);
                const efficiencies = miners.map(m => m.efficiency || 40);

                // Destroy previous chart if exists
                if (this.charts.efficiency) {
                    this.charts.efficiency.destroy();
                }

                this.charts.efficiency = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Power Efficiency (W/TH)',
                            data: efficiencies,
                            borderColor: '#06b6d4',
                            backgroundColor: 'rgba(6, 182, 212, 0.1)',
                            borderWidth: 3,
                            tension: 0.4,
                            fill: true,
                            pointRadius: 4,
                            pointHoverRadius: 7,
                            pointBackgroundColor: '#06b6d4',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            pointHoverBackgroundColor: '#10b981',
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#888',
                                    font: { family: "'Space Mono', monospace", size: 13, weight: '600' },
                                    padding: 16,
                                    boxWidth: 14,
                                    boxHeight: 14,
                                    borderRadius: 3,
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: 'rgba(17, 24, 39, 0.95)',
                                borderColor: '#06b6d4',
                                borderWidth: 1,
                                titleColor: '#06b6d4',
                                bodyColor: '#aaa',
                                cornerRadius: 6,
                                padding: 12,
                                callbacks: {
                                    title: function(context) {
                                        return 'Efficiency Reading ' + context[0].label;
                                    },
                                    label: function(context) {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(1) + ' W/TH';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    display: false,
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#888',
                                    font: { family: "'Space Mono', monospace", size: 11, weight: '600' },
                                    padding: 8
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Watts per TH',
                                    color: '#06b6d4',
                                    font: { family: "'Space Mono', monospace", size: 13, weight: 'bold' }
                                },
                                grid: {
                                    color: 'rgba(31, 41, 55, 0.3)',
                                    drawBorder: false
                                },
                                ticks: {
                                    color: '#888',
                                    font: { family: "'Courier New', monospace", size: 11, weight: 'bold' },
                                    padding: 8,
                                    callback: function(value) {
                                        return value.toFixed(0);
                                    }
                                }
                            }
                        }
                    }
                });
            },

            renderPoolComparisonChart() {
                if (!this.data) return;
                const svg = document.getElementById('poolComparisonChart');
                const chartContent = svg.querySelector('#chartContent');
                chartContent.innerHTML = '';

                this.updatePoolComparisonStats();

                const hasPoolData = this.poolData && Object.keys(this.poolData).length > 0;
                
                const miners = Object.keys(this.data).sort();
                const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
                const width = viewBox[2];
                const height = viewBox[3];
                const padding = { top: 50, right: 60, bottom: 50, left: 80 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;

                let maxHash = 0;
                miners.forEach(m => {
                    const local = this.data[m]?.hashrate_1m || 0;
                    const pool = (this.poolData && this.poolData[m]?.hashrate) || 0;
                    maxHash = Math.max(maxHash, local, pool);
                });
                maxHash = Math.max(maxHash, 10);

                const barWidth = (chartWidth / miners.length) * 0.35;
                const groupWidth = chartWidth / miners.length;

                for (let i = 0; i <= 5; i++) {
                    const y = height - padding.bottom - (i * chartHeight / 5);
                    const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    gridLine.setAttribute('x1', padding.left);
                    gridLine.setAttribute('y1', y);
                    gridLine.setAttribute('x2', width - padding.right);
                    gridLine.setAttribute('y2', y);
                    gridLine.setAttribute('stroke', '#1a3a3f');
                    gridLine.setAttribute('stroke-dasharray', '3 3');
                    chartContent.appendChild(gridLine);

                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', padding.left - 15);
                    label.setAttribute('y', y + 5);
                    label.setAttribute('text-anchor', 'end');
                    label.setAttribute('fill', '#06b6d4');
                    label.setAttribute('font-size', '11');
                    label.setAttribute('font-weight', 'bold');
                    label.textContent = (maxHash * i / 5).toFixed(1) + ' TH/s';
                    chartContent.appendChild(label);
                }

                miners.forEach((miner, i) => {
                    const localHash = this.data[miner]?.hashrate_1m || 0;
                    const poolHash = (hasPoolData && this.poolData && this.poolData[miner]?.hashrate) || 0;
                    
                    const x = padding.left + (i * groupWidth) + (groupWidth - barWidth * 2 - 8) / 2;
                    
                    const localHeight = (localHash / maxHash) * chartHeight;
                    const localBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    localBar.setAttribute('x', x);
                    localBar.setAttribute('y', height - padding.bottom - localHeight);
                    localBar.setAttribute('width', barWidth);
                    localBar.setAttribute('height', localHeight);
                    localBar.setAttribute('fill', 'url(#localGradient)');
                    localBar.setAttribute('stroke', '#06b6d4');
                    localBar.setAttribute('stroke-width', '2');
                    localBar.setAttribute('filter', 'url(#glow)');
                    localBar.setAttribute('class', 'chart-bar');
                    chartContent.appendChild(localBar);

                    const localLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    localLabel.setAttribute('x', x + barWidth / 2);
                    localLabel.setAttribute('y', height - padding.bottom - localHeight - 8);
                    localLabel.setAttribute('text-anchor', 'middle');
                    localLabel.setAttribute('fill', '#06b6d4');
                    localLabel.setAttribute('font-size', '10');
                    localLabel.setAttribute('font-weight', 'bold');
                    localLabel.textContent = localHash.toFixed(1);
                    chartContent.appendChild(localLabel);

                    if (hasPoolData && poolHash > 0) {
                        const poolHeight = (poolHash / maxHash) * chartHeight;
                        const poolBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        poolBar.setAttribute('x', x + barWidth + 8);
                        poolBar.setAttribute('y', height - padding.bottom - poolHeight);
                        poolBar.setAttribute('width', barWidth);
                        poolBar.setAttribute('height', poolHeight);
                        poolBar.setAttribute('fill', 'url(#poolGradient)');
                        poolBar.setAttribute('stroke', '#f59e0b');
                        poolBar.setAttribute('stroke-width', '2');
                        poolBar.setAttribute('filter', 'url(#glow)');
                        poolBar.setAttribute('class', 'chart-bar');
                        chartContent.appendChild(poolBar);

                        const poolLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        poolLabel.setAttribute('x', x + barWidth + 8 + barWidth / 2);
                        poolLabel.setAttribute('y', height - padding.bottom - poolHeight - 8);
                        poolLabel.setAttribute('text-anchor', 'middle');
                        poolLabel.setAttribute('fill', '#f59e0b');
                        poolLabel.setAttribute('font-size', '10');
                        poolLabel.setAttribute('font-weight', 'bold');
                        poolLabel.textContent = poolHash.toFixed(1);
                        chartContent.appendChild(poolLabel);
                    }

                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x + barWidth + 4);
                    label.setAttribute('y', height - padding.bottom + 25);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', '#888');
                    label.setAttribute('font-size', '13');
                    label.setAttribute('font-weight', 'bold');
                    label.textContent = miner;
                    chartContent.appendChild(label);
                });

                if (!hasPoolData) {
                    const statusRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    statusRect.setAttribute('x', width - 280);
                    statusRect.setAttribute('y', 15);
                    statusRect.setAttribute('width', 265);
                    statusRect.setAttribute('height', 25);
                    statusRect.setAttribute('fill', 'rgba(239, 68, 68, 0.1)');
                    statusRect.setAttribute('stroke', '#ef4444');
                    statusRect.setAttribute('stroke-width', '1.5');
                    statusRect.setAttribute('rx', '4');
                    chartContent.appendChild(statusRect);

                    const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    statusText.setAttribute('x', width - 280 + 8);
                    statusText.setAttribute('y', 33);
                    statusText.setAttribute('fill', '#ef4444');
                    statusText.setAttribute('font-size', '11');
                    statusText.setAttribute('font-weight', 'bold');
                    statusText.textContent = '‚ö†Ô∏è Luxor data unavailable - Local data only';
                    chartContent.appendChild(statusText);
                }
            },

            updatePoolComparisonStats() {
                let localTotal = 0;
                let poolTotal = 0;
                let matchedMiners = 0;

                Object.keys(this.data).forEach(miner => {
                    localTotal += this.data[miner]?.hashrate_1m || 0;
                    if (this.poolData && this.poolData[miner]) {
                        poolTotal += this.poolData[miner].hashrate || 0;
                        matchedMiners++;
                    }
                });

                const localCard = document.getElementById('localHashrateTotal');
                const poolCard = document.getElementById('poolHashrateTotal');
                const diffCard = document.getElementById('hashrateDifference');
                const varCard = document.getElementById('hashrateVariance');
                const statusCard = document.getElementById('poolStatus');

                if (localCard) localCard.textContent = localTotal.toFixed(2) + ' TH/s';
                if (poolCard) poolCard.textContent = poolTotal.toFixed(2) + ' TH/s';
                
                const difference = Math.abs(localTotal - poolTotal);
                const variance = localTotal > 0 ? ((difference / localTotal) * 100) : 0;
                
                if (diffCard) diffCard.textContent = difference.toFixed(2) + ' TH/s';
                if (varCard) varCard.textContent = variance.toFixed(1) + '%';
                
                if (statusCard) {
                    if (poolTotal > 0) {
                        statusCard.style.color = '#10b981';
                        statusCard.textContent = '‚úì Pool data active - ' + matchedMiners + ' miners matched';
                    } else {
                        statusCard.style.color = '#f59e0b';
                        statusCard.textContent = '‚ö†Ô∏è Awaiting Luxor API response...';
                    }
                }
            },

            getMinerData(name) {
                return Object.values(this.data || {}).find(m => m.name === name) || null;
            },

            renderStats() {
                const miner = this.getMinerData(this.selectedMiner);
                const grid = document.getElementById('statsGrid');
                
                if (!miner) {
                    grid.innerHTML = '<div class="error">No data available for this miner</div>';
                    return;
                }

                const stats = [
                    { label: 'Hashrate', value: miner.hashrate_1m ? miner.hashrate_1m.toFixed(2) + ' TH/s' : 'N/A', icon: '‚ö°' },
                    { label: 'Efficiency', value: miner.efficiency ? miner.efficiency.toFixed(1) + ' W/TH' : 'N/A', icon: 'üìä' },
                    { label: 'Power', value: miner.power ? miner.power.toFixed(0) + ' W' : 'N/A', icon: 'üîå' },
                    { label: 'Uptime', value: miner.uptime ? miner.uptime.toFixed(1) + '%' : 'N/A', icon: '‚è±Ô∏è' },
                    { label: 'Temperature', value: miner.temp ? miner.temp.toFixed(1) + '¬∞C' : 'N/A', icon: 'üå°Ô∏è' },
                    { label: 'Status', value: miner.alive ? 'üü¢ Online' : 'üî¥ Offline', icon: 'üì°' }
                ];

                grid.innerHTML = stats.map(stat => `
                    <div class="stat-card">
                        <div class="stat-icon">${stat.icon}</div>
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value">${stat.value}</div>
                    </div>
                `).join('');
            },

            renderSystemOverview() {
                const container = document.getElementById('systemOverview');
                if (!this.data) return;

                const miners = Object.values(this.data);
                const online = miners.filter(m => m.alive);
                const offline = miners.filter(m => !m.alive);

                let html = '<div>';
                
                if (offline.length > 0) {
                    html += `<div class="metric-row"><span class="metric-label">üî¥ Offline: ${offline.map(m => m.name).join(', ')}</span></div>`;
                }

                online.forEach(miner => {
                    const tempStatus = miner.temp > 75 ? 'üî¥' : miner.temp > 65 ? 'üü°' : 'üü¢';
                    const hashrate = miner.hashrate_1m?.toFixed(2) || 'N/A';
                    const temp = miner.temp?.toFixed(1) || 'N/A';
                    html += `
                        <div class="metric-row">
                            <span class="metric-label">Miner ${miner.name} ${tempStatus}</span>
                            <span class="metric-value">${hashrate} TH/s | ${temp}¬∞C</span>
                        </div>
                    `;
                });

                html += '</div>';
                container.innerHTML = html;
            },

            renderRecommendations() {
                const container = document.getElementById('recommendations');
                if (!this.data) return;

                const miners = Object.values(this.data);
                const online = miners.filter(m => m.alive);
                const recommendations = [];

                const offline = miners.filter(m => !m.alive);
                if (offline.length > 0) {
                    recommendations.push(`üî¥ ${offline.length} miner(s) offline - verify power and network`);
                }

                const highTemp = online.filter(m => m.temp > 75);
                if (highTemp.length > 0) {
                    recommendations.push(`üå°Ô∏è ${highTemp.length} miner(s) above 75¬∞C - improve cooling/ventilation`);
                }

                const lowHash = online.filter(m => (m.hashrate_1m || 0) < 7);
                if (lowHash.length > 0) {
                    recommendations.push(`‚ö° ${lowHash.length} miner(s) underperforming - check for throttling`);
                }

                const highEfficiency = online.filter(m => m.efficiency && m.efficiency > 45);
                if (highEfficiency.length > 0) {
                    recommendations.push(`üí° ${highEfficiency.length} miner(s) with high W/TH - consider tuning`);
                }

                if (recommendations.length === 0 && online.length > 0) {
                    recommendations.push('‚úÖ Fleet operating optimally - all systems nominal');
                }

                const html = recommendations.map(rec => `
                    <div class="recommendation-item">${rec}</div>
                `).join('');

                container.innerHTML = html || '<div class="recommendation-item">No data available</div>';
            }
        };

        document.addEventListener('DOMContentLoaded', () => app.init());
    </script>
                    
                    // Local Bar with glow
                    const localHeight = (localHash / maxHash) * chartHeight;
                    const localBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    localBar.setAttribute('x', x);
                    localBar.setAttribute('y', height - padding.bottom - localHeight);
                    localBar.setAttribute('width', barWidth);
                    localBar.setAttribute('height', localHeight);
                    localBar.setAttribute('fill', 'url(#localGradient)');
                    localBar.setAttribute('stroke', '#06b6d4');
                    localBar.setAttribute('stroke-width', '2');
                    localBar.setAttribute('filter', 'url(#glow)');
                    localBar.setAttribute('class', 'chart-bar');
                    localBar.setAttribute('data-value', localHash.toFixed(2));
                    chartContent.appendChild(localBar);

                    // Value label for local bar
                    const localLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    localLabel.setAttribute('x', x + barWidth / 2);
                    localLabel.setAttribute('y', height - padding.bottom - localHeight - 8);
                    localLabel.setAttribute('text-anchor', 'middle');
                    localLabel.setAttribute('fill', '#06b6d4');
                    localLabel.setAttribute('font-size', '10');
                    localLabel.setAttribute('font-weight', 'bold');
                    localLabel.textContent = localHash.toFixed(1);
                    chartContent.appendChild(localLabel);

                    // Pool Bar (only if data exists)
                    if (hasPoolData && poolHash > 0) {
                        const poolHeight = (poolHash / maxHash) * chartHeight;
                        const poolBar = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        poolBar.setAttribute('x', x + barWidth + 8);
                        poolBar.setAttribute('y', height - padding.bottom - poolHeight);
                        poolBar.setAttribute('width', barWidth);
                        poolBar.setAttribute('height', poolHeight);
                        poolBar.setAttribute('fill', 'url(#poolGradient)');
                        poolBar.setAttribute('stroke', '#f59e0b');
                        poolBar.setAttribute('stroke-width', '2');
                        poolBar.setAttribute('filter', 'url(#glow)');
                        poolBar.setAttribute('class', 'chart-bar');
                        chartContent.appendChild(poolBar);

                        // Value label for pool bar
                        const poolLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        poolLabel.setAttribute('x', x + barWidth + 8 + barWidth / 2);
                        poolLabel.setAttribute('y', height - padding.bottom - poolHeight - 8);
                        poolLabel.setAttribute('text-anchor', 'middle');
                        poolLabel.setAttribute('fill', '#f59e0b');
                        poolLabel.setAttribute('font-size', '10');
                        poolLabel.setAttribute('font-weight', 'bold');
                        poolLabel.textContent = poolHash.toFixed(1);
                        chartContent.appendChild(poolLabel);
                    }

                    // Miner label below X-axis
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x + barWidth + 4);
                    label.setAttribute('y', height - padding.bottom + 25);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('fill', '#888');
                    label.setAttribute('font-size', '13');
                    label.setAttribute('font-weight', 'bold');
                    label.textContent = miner;
                    chartContent.appendChild(label);
                });

                // Status indicator
                if (!hasPoolData) {
                    const statusRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    statusRect.setAttribute('x', width - 280);
                    statusRect.setAttribute('y', 15);
                    statusRect.setAttribute('width', 265);
                    statusRect.setAttribute('height', 25);
                    statusRect.setAttribute('fill', 'rgba(239, 68, 68, 0.1)');
                    statusRect.setAttribute('stroke', '#ef4444');
                    statusRect.setAttribute('stroke-width', '1.5');
                    statusRect.setAttribute('rx', '4');
                    chartContent.appendChild(statusRect);

                    const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    statusText.setAttribute('x', width - 280 + 8);
                    statusText.setAttribute('y', 33);
                    statusText.setAttribute('fill', '#ef4444');
                    statusText.setAttribute('font-size', '11');
                    statusText.setAttribute('font-weight', 'bold');
                    statusText.textContent = '‚ö†Ô∏è Luxor data unavailable - Local data only';
                    chartContent.appendChild(statusText);
                }
            },

            updatePoolComparisonStats() {
                // Calculate totals
                let localTotal = 0;
                let poolTotal = 0;
                let matchedMiners = 0;

                Object.keys(this.data).forEach(miner => {
                    localTotal += this.data[miner]?.hashrate_1m || 0;
                    if (this.poolData && this.poolData[miner]) {
                        poolTotal += this.poolData[miner].hashrate || 0;
                        matchedMiners++;
                    }
                });

                // Update stat cards
                const localCard = document.getElementById('localHashrateTotal');
                const poolCard = document.getElementById('poolHashrateTotal');
                const diffCard = document.getElementById('hashrateDifference');
                const varCard = document.getElementById('hashrateVariance');
                const statusCard = document.getElementById('poolStatus');

                if (localCard) localCard.textContent = localTotal.toFixed(2) + ' TH/s';
                if (poolCard) poolCard.textContent = poolTotal.toFixed(2) + ' TH/s';
                
                const difference = Math.abs(localTotal - poolTotal);
                const variance = localTotal > 0 ? ((difference / localTotal) * 100) : 0;
                
                if (diffCard) diffCard.textContent = difference.toFixed(2) + ' TH/s';
                if (varCard) varCard.textContent = variance.toFixed(1) + '%';
                
                if (statusCard) {
                    if (poolTotal > 0) {
                        statusCard.style.color = '#10b981';
                        statusCard.textContent = '‚úì Pool data active - ' + matchedMiners + ' miners matched';
                    } else {
                        statusCard.style.color = '#f59e0b';
                        statusCard.textContent = '‚ö†Ô∏è Awaiting Luxor API response...';
                    }
                }
            },

            getMinerData(name) {
                return this.data?.[name] || null;
            },

            renderStats() {
                const miner = this.getMinerData(this.selectedMiner);
                const grid = document.getElementById('statsGrid');
                
                if (!miner) {
                    grid.innerHTML = '<div class="error">No data available for this miner</div>';
                    return;
                }

                const stats = [
                    { label: 'Hashrate', value: miner.hashrate_1m ? miner.hashrate_1m.toFixed(2) + ' TH/s' : 'N/A', icon: '‚ö°' },
                    { label: 'Efficiency', value: miner.efficiency ? miner.efficiency.toFixed(1) + ' W/TH' : 'N/A', icon: 'üìä' },
                    { label: 'Power', value: miner.power ? miner.power.toFixed(0) + ' W' : 'N/A', icon: 'üîå' },
                    { label: 'Uptime', value: miner.uptime ? miner.uptime.toFixed(1) + '%' : 'N/A', icon: '‚è±Ô∏è' },
                    { label: 'Temperature', value: miner.temp ? miner.temp.toFixed(1) + '¬∞C' : 'N/A', icon: 'üå°Ô∏è' },
                    { label: 'Status', value: miner.alive ? 'üü¢ Online' : 'üî¥ Offline', icon: 'üì°' }
                ];

                grid.innerHTML = stats.map(stat => `
                    <div class="stat-card">
                        <div class="stat-icon">${stat.icon}</div>
                        <div class="stat-label">${stat.label}</div>
                        <div class="stat-value">${stat.value}</div>
                    </div>
                `).join('');
            },

            renderFleetStatus() {
                // Legacy function - replaced by charts
            },

            renderPerformanceMetrics() {
                // Legacy function - replaced by charts
            },

            renderSystemOverview() {
                const container = document.getElementById('systemOverview');
                if (!this.data) return;

                const miners = Object.values(this.data);
                const online = miners.filter(m => m.alive);
                const offline = miners.filter(m => !m.alive);

                let html = '<div>';
                
                if (offline.length > 0) {
                    html += `<div class="metric-row"><span class="metric-label">üî¥ Offline: ${offline.map(m => m.name).join(', ')}</span></div>`;
                }

                online.forEach(miner => {
                    const tempStatus = miner.temp > 75 ? 'üî¥' : miner.temp > 65 ? 'üü°' : 'üü¢';
                    const hashrate = miner.hashrate_1m?.toFixed(2) || 'N/A';
                    const temp = miner.temp?.toFixed(1) || 'N/A';
                    html += `
                        <div class="metric-row">
                            <span class="metric-label">Miner ${miner.name} ${tempStatus}</span>
                            <span class="metric-value">${hashrate} TH/s | ${temp}¬∞C</span>
                        </div>
                    `;
                });

                html += '</div>';
                container.innerHTML = html;
            },

            renderRecommendations() {
                const container = document.getElementById('recommendations');
                if (!this.data) return;

                const miners = Object.values(this.data);
                const online = miners.filter(m => m.alive);
                const recommendations = [];

                // Check for offline miners
                const offline = miners.filter(m => !m.alive);
                if (offline.length > 0) {
                    recommendations.push(`üî¥ ${offline.length} miner(s) offline - verify power and network`);
                }

                // Check for high temps
                const highTemp = online.filter(m => m.temp > 75);
                if (highTemp.length > 0) {
                    recommendations.push(`üå°Ô∏è ${highTemp.length} miner(s) above 75¬∞C - improve cooling/ventilation`);
                }

                // Check for low hashrate
                const lowHash = online.filter(m => (m.hashrate_1m || 0) < 7);
                if (lowHash.length > 0) {
                    recommendations.push(`‚ö° ${lowHash.length} miner(s) underperforming - check for throttling`);
                }

                // Check for high efficiency
                const highEfficiency = online.filter(m => m.efficiency && m.efficiency > 45);
                if (highEfficiency.length > 0) {
                    recommendations.push(`üí° ${highEfficiency.length} miner(s) with high W/TH - consider tuning`);
                }

                // Positive feedback
                if (recommendations.length === 0 && online.length > 0) {
                    recommendations.push('‚úÖ Fleet operating optimally - all systems nominal');
                }

                const html = recommendations.map(rec => `
                    <div class="recommendation-item">${rec}</div>
                `).join('');

                container.innerHTML = html || '<div class="recommendation-item">No data available</div>';
            },

            renderMinerAnalysis() {
                const container = document.getElementById('minerAnalysis');
                if (!this.data) return;

                const miners = Object.values(this.data).filter(m => m.alive);
                let analysisHtml = '';

                miners.forEach(miner => {
                    const insights = this.generateMinerInsights(miner);
                    
                    analysisHtml += `
                        <div style="margin-bottom: 20px; padding: 16px; background: rgba(6, 182, 212, 0.05); border-left: 3px solid #06b6d4; border-radius: 6px;">
                            <div style="font-weight: 700; color: #06b6d4; margin-bottom: 12px; font-size: 14px;">Miner ${miner.name}</div>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                ${insights.map((insight, idx) => `
                                    <div style="color: #aaa; font-size: 13px; line-height: 1.5; display: flex; gap: 8px;">
                                        <span style="color: #10b981; font-weight: 600; min-width: 20px;">${idx + 1}.</span>
                                        <span>${insight}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = analysisHtml || '<div class="recommendation-item">No miners to analyze</div>';
            },

            generateMinerInsights(miner) {
                const insights = [];
                const hash = miner.hashrate_1m || 0;
                const eff = miner.efficiency || 0;
                const temp = miner.temp || 0;
                const power = miner.power || 0;
                const acceptance = (miner.sharesAccepted || 0) / ((miner.sharesAccepted || 0) + (miner.sharesRejected || 0) || 1);

                // Insight 1: Hashrate Performance
                if (hash > 8.5) {
                    insights.push(`‚úÖ Excellent hashrate at ${hash.toFixed(2)} TH/s - performing above fleet average`);
                } else if (hash > 7.5) {
                    insights.push(`‚ö° Good hashrate at ${hash.toFixed(2)} TH/s - stable and consistent performance`);
                } else if (hash > 6.5) {
                    insights.push(`‚ö†Ô∏è Moderate hashrate at ${hash.toFixed(2)} TH/s - within acceptable range but monitor for drift`);
                } else {
                    insights.push(`üî¥ Low hashrate at ${hash.toFixed(2)} TH/s - investigate for hardware issues or throttling`);
                }

                // Insight 2: Efficiency
                if (eff < 25) {
                    insights.push(`üí™ Excellent efficiency at ${eff.toFixed(1)} W/TH - optimal power utilization, highly profitable`);
                } else if (eff < 35) {
                    insights.push(`‚úÖ Good efficiency at ${eff.toFixed(1)} W/TH - balanced power-to-hash ratio, performing well`);
                } else if (eff < 45) {
                    insights.push(`‚ö†Ô∏è Fair efficiency at ${eff.toFixed(1)} W/TH - acceptable but room for tuning and optimization`);
                } else {
                    insights.push(`üîß Poor efficiency at ${eff.toFixed(1)} W/TH - high power draw, consider BIOS tuning or kernel adjustment`);
                }

                // Insight 3: Thermal & Share Health
                if (temp > 70) {
                    insights.push(`üå°Ô∏è Running hot at ${temp.toFixed(0)}¬∞C - improve airflow or increase fan speed to extend hardware lifespan`);
                } else if (temp > 60) {
                    insights.push(`üü° Moderate temperature at ${temp.toFixed(0)}¬∞C - acceptable but monitor for thermal creep during sustained loads`);
                } else {
                    insights.push(`‚ùÑÔ∏è Excellent thermal management at ${temp.toFixed(0)}¬∞C - cool operation with strong share acceptance (${(acceptance * 100).toFixed(1)}%)`);
                }

                return insights;
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            app.init();
            // Render miner analysis after initial data load
            setTimeout(() => app.renderMinerAnalysis(), 500);
        });
    </script>
</body>
</html>
